This chapter describes the basic concepts of the language.


\section{Values and Types}

BASIC is a \emph{Dynamically typed language}, which means variables do not know which group they should barge in; only values of the variable do. In fact, there are no type definitions in the language. We do want our variables to feel themselves awkward.

There are five basic types: \emph{nil}, \emph{boolean}, \emph{number}, \emph{string} and \emph{array}. \emph{Nil} is the type of the literal value \textbf{NIL}, who likes to possess nothing (I think he's secretly a buddhist). \emph{Boolean} is the type of the values that is either \textbf{TRUE} or \textbf{FALSE}, he knows no in-between. Both \textbf{NIL} and \textbf{FALSE} makes condition \emph{false}, any other values, even the number 0, makes it \emph{true}, because \emph{0 is truly a number, ya See-barbarians}. \emph{Number} represents real (double-precision floating-point) numbers. Operations on numbers follow the same rules of the underlying virtual machine\footnote{if you are not a computer person, just disregard}, and such machines must follow the IEEE 754 standard\footnote{ditto.}. \emph{String} represents immutable\footnote{cannot be altered directly} sequences of bytes. However, you can't weave them to make something like \emph{string array}\footnote{future feature\ldots maybe\ldots? Probably not\ldots}.

\subsection{Arrays} are somewhat special; they can be work as both array and a number. When you read array variable as an array using index notation \code{MYARRAY(3)}, the variable will behave as an ordinary array. However, if you evaluate the array as a number, using \code{MYARRAY}, their first element is returned, without any errors. This feature is there to use FOR statement conveniently and \emph{to screw ya debugging}.